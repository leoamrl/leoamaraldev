(()=>{var __webpack_modules__={"./src/sass/style.scss":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n\n\n//# sourceURL=webpack://otherside/./src/sass/style.scss?")},"./src/js/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _sass_style_scss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../sass/style.scss */ "./src/sass/style.scss");\n/* harmony import */ var _modules_preloader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modules/preloader */ "./src/js/modules/preloader.js");\n/* harmony import */ var _modules_preloader__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_modules_preloader__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _modules_noise__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modules/noise */ "./src/js/modules/noise.js");\n/* harmony import */ var _modules_noise__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_modules_noise__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _modules_menu__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modules/menu */ "./src/js/modules/menu.js");\n/* harmony import */ var _modules_menu__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_modules_menu__WEBPACK_IMPORTED_MODULE_3__);\n\n\n\n\n\n//# sourceURL=webpack://otherside/./src/js/index.js?')},"./src/js/modules/menu.js":()=>{eval("const menuTrigger = document.querySelector('[data-selector=menuTrigger]'),\n      menu = document.querySelector('[data-selector=menu]'),\n      aboutTrigger = document.querySelector('[data-selector=aboutTrigger]'),\n      contactTrigger = document.querySelectorAll('[data-selector=contactTrigger]');\n\nfunction openMenu(e) {\n  menu.classList.toggle('open')\n  menuTrigger.classList.toggle('open')\n}\n\nfunction openAbout(e) {\n  console.log('about opened')\n  menu.classList.toggle('open')\n  menuTrigger.classList.toggle('open')\n}\n\nmenuTrigger.addEventListener('click', openMenu)\n\naboutTrigger.addEventListener('click', openAbout)\n\n\n//# sourceURL=webpack://otherside/./src/js/modules/menu.js?")},"./src/js/modules/noise.js":()=>{eval("\nlet initialise = function() {\n  \n  let application = new Application();\n\n  let vfield = new VectorField();\n  \n  application.addActor(vfield);\n\n  \n  \n  let stage = application.stage;\n  document.body.appendChild(stage);\n  application.onPointerMove({ clientX: window.innerWidth / 2, clientY: window.innerHeight / 2 });\n  application.render();\n  application.animating = true;\n  \n  return;\n}\n\nwindow.addEventListener('load', ()=> {\n  initialise();\n});\n\nconst conversionFactor = 180 / Math.PI;\n\nlet radianToDegrees = function(radian) {\n\treturn radian * conversionFactor;\n}\nlet degreesToRadian = function(degrees) {\n\treturn degrees / conversionFactor;\n}\n\n// Taken from https://github.com/wethegit/wtc-vector\n/**\n * A basic 2D Vector class that provides simple algebraic functionality in the form\n * of 2D Vectors.\n *\n * We use Getters/setters for both principle properties (x & y) as well as virtual\n * properties (rotation, length etc.).\n *\n * @class Vector\n * @author Liam Egan <liam@wethecollective.com>\n * @version 0.1.1\n * @created Dec 19, 2016\n */\nclass Vector {\n\n\t/**\n\t * The Vector Class constructor\n\t *\n\t * @constructor\n\t * @param {number} x \t\t\t\tThe x coord\n\t * @param {number} y \t\t\t\tThe y coord\n\t */\n  constructor(x, y){\n    this.x = x;\n    this.y = y;\n  }\n\n  /**\n   * Resets the vector coordinates\n   *\n   * @public\n\t * @param {number} x \t\t\t\tThe x coord\n\t * @param {number} y \t\t\t\tThe y coord\n   */\n\treset(x, y) {\n    this.x = x;\n    this.y = y;\n\t}\n\n\t/**\n\t * Clones the vector\n\t *\n\t * @public\n\t * @return {Vector}\t\t\t\t\tThe cloned vector\n\t */\n  clone() {\n    return new Vector(this.x, this.y);\n  }\n\n  /**\n   * Adds one vector to another.\n   *\n   * @public\n   * @chainable\n   * @param  {Vector}  vector The vector to add to this one\n   * @return {Vector}\t\t\t\t\tReturns itself, modified\n   */\n  add(vector) {\n    this.x += vector.x;\n    this.y += vector.y;\n    return this;\n  }\n  /**\n   * Clones the vector and adds the vector to it instead\n   *\n   * @public\n   * @chainable\n   * @param  {Vector}  vector The vector to add to this one\n   * @return {Vector}\t\t\t\t\tReturns the clone of itself, modified\n   */\n  addNew(vector) {\n    let v = this.clone();\n    return v.add(vector);\n  }\n\n  /**\n   * Adds a scalar to the vector, modifying both the x and y\n   *\n   * @public\n   * @chainable\n   * @param  {number}  scalar The scalar to add to the vector\n   * @return {Vector}\t\t\t\t\tReturns itself, modified\n   */\n  addScalar(scalar) {\n    return this.add(new Vector(scalar, scalar));\n  }\n  /**\n   * Clones the vector and adds the scalar to it instead\n   *\n   * @public\n   * @chainable\n   * @param  {number}  scalar The scalar to add to the vector\n   * @return {Vector}\t\t\t\t\tReturns the clone of itself, modified\n   */\n  addScalarNew(scalar) {\n    let v = this.clone();\n    return v.addScalar(scalar);\n  }\n\n  /**\n   * Subtracts one vector from another.\n   *\n   * @public\n   * @chainable\n   * @param  {Vector}  vector The vector to subtract from this one\n   * @return {Vector}\t\t\t\t\tReturns itself, modified\n   */\n  subtract(vector) {\n    this.x -= vector.x;\n    this.y -= vector.y;\n    return this;\n  }\n  /**\n   * Clones the vector and subtracts the vector from it instead\n   *\n   * @public\n   * @chainable\n   * @param  {Vector}  vector The vector to subtract from this one\n   * @return {Vector}\t\t\t\t\tReturns the clone of itself, modified\n   */\n  subtractNew(vector) {\n    let v = this.clone();\n    return v.subtract(vector);\n  }\n\n  /**\n   * Subtracts a scalar from the vector, modifying both the x and y\n   *\n   * @public\n   * @chainable\n   * @param  {number}  scalar The scalar to subtract from the vector\n   * @return {Vector}\t\t\t\t\tReturns itself, modified\n   */\n  subtractScalar(scalar) {\n    return this.subtract(new Vector(scalar, scalar));\n  }\n  /**\n   * Clones the vector and subtracts the scalar from it instead\n   *\n   * @public\n   * @chainable\n   * @param  {number}  scalar The scalar to add to the vector\n   * @return {Vector}\t\t\t\t\tReturns the clone of itself, modified\n   */\n  subtractScalarNew(scalar) {\n    let v = this.clone();\n    return v.subtractScalar(scalar);\n  }\n\n  /**\n   * Divides one vector by another.\n   *\n   * @public\n   * @chainable\n   * @param  {Vector}  vector The vector to divide this by\n   * @return {Vector}\t\t\t\t\tReturns itself, modified\n   */\n  divide(vector) {\n    if(vector.x !== 0) {\n      this.x /= vector.x\n    } else {\n      this.x = 0;\n    }\n    if(vector.y !== 0) {\n      this.y /= vector.y\n    } else {\n      this.y = 0;\n    }\n    return this;\n  }\n  /**\n   * Clones the vector and divides it by the vector instead\n   *\n   * @public\n   * @chainable\n   * @param  {Vector}  vector The vector to divide the clone by\n   * @return {Vector}\t\t\t\t\tReturns the clone of itself, modified\n   */\n  divideNew(vector) {\n    let v = this.clone();\n    return v.divide(vector);\n  }\n\n  /**\n   * Divides the vector by a scalar.\n   *\n   * @public\n   * @chainable\n   * @param  {number}  scalar The scalar to divide both x and y by\n   * @return {Vector}\t\t\t\t\tReturns itself, modified\n   */\n  divideScalar(scalar) {\n    var v = new Vector(scalar, scalar);\n    return this.divide(v);\n  }\n  /**\n   * Clones the vector and divides it by the provided scalar.\n   *\n   * @public\n   * @chainable\n   * @param  {number}  scalar The scalar to divide both x and y by\n   * @return {Vector}\t\t\t\t\tReturns the clone of itself, modified\n   */\n  divideScalarNew(scalar) {\n    let v = this.clone();\n    return v.divideScalar(scalar);\n  }\n\n  /**\n   * Multiplies one vector by another.\n   *\n   * @public\n   * @chainable\n   * @param  {Vector}  vector The vector to multiply this by\n   * @return {Vector}\t\t\t\t\tReturns itself, modified\n   */\n  multiply(vector) {\n    this.x *= vector.x;\n    this.y *= vector.y;\n    return this;\n  }\n  /**\n   * Clones the vector and multiplies it by the vector instead\n   *\n   * @public\n   * @chainable\n   * @param  {Vector}  vector The vector to multiply the clone by\n   * @return {Vector}\t\t\t\t\tReturns the clone of itself, modified\n   */\n  multiplyNew(vector) {\n    let v = this.clone();\n    return v.multiply(vector);\n  }\n\n  /**\n   * Multiplies the vector by a scalar.\n   *\n   * @public\n   * @chainable\n   * @param  {number}  scalar The scalar to multiply both x and y by\n   * @return {Vector}\t\t\t\t\tReturns itself, modified\n   */\n  multiplyScalar(scalar) {\n    var v = new Vector(scalar, scalar);\n    return this.multiply(v);\n  }\n  /**\n   * Clones the vector and multiplies it by the provided scalar.\n   *\n   * @public\n   * @chainable\n   * @param  {number}  scalar The scalar to multiply both x and y by\n   * @return {Vector}\t\t\t\t\tReturns the clone of itself, modified\n   */\n  multiplyScalarNew(scalar) {\n    let v = this.clone();\n    return v.multiplyScalar(scalar);\n  }\n\n  /**\n   * Alias of {@link Vector#multiplyScalar__anchor multiplyScalar}\n   */\n  scale(scalar) {\n    return this.multiplyScalar(scalar);\n  }\n  /**\n   * Alias of {@link Vector#multiplyScalarNew__anchor multiplyScalarNew}\n   */\n  scaleNew(scalar) {\n    return this.multiplyScalarNew(scalar);\n  }\n\n  /**\n   * Rotates a vecor by a given amount, provided in radians.\n   *\n   * @public\n   * @chainable\n   * @param  {number}  radian The angle, in radians, to rotate the vector by\n   * @return {Vector}\t\t\t\t\tReturns itself, modified\n   */\n  rotate(radian) {\n  \tvar x = (this.x * Math.cos(radian)) - (this.y * Math.sin(radian));\n  \tvar y = (this.x * Math.sin(radian)) + (this.y * Math.cos(radian));\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\n  \treturn this;\n  }\n  /**\n   * Clones the vector and rotates it by the supplied radian value\n   *\n   * @public\n   * @chainable\n   * @param  {number}  radian The angle, in radians, to rotate the vector by\n   * @return {Vector}\t\t\t\t\tReturns the clone of itself, modified\n   */\n  rotateNew(radian) {\n    let v = this.clone();\n    return v.rotate(radian);\n  }\n\n\t/**\n\t * Rotates a vecor by a given amount, provided in degrees. Converts the degree\n\t * value to radians and runs the rotaet method.\n\t *\n\t * @public\n\t * @chainable\n\t * @param  {number}  degrees The angle, in degrees, to rotate the vector by\n\t * @return {Vector}\t\t\t\t\t\tReturns itself, modified\n\t */\n  rotateDeg(degrees) {\n    return this.rotate(degreesToRadian(degrees));\n  }\n  /**\n   * Clones the vector and rotates it by the supplied degree value\n   *\n   * @public\n   * @chainable\n\t * @param  {number}  degrees The angle, in degrees, to rotate the vector by\n   * @return {Vector}\t\t\t\t\t Returns the clone of itself, modified\n   */\n  rotateDegNew(degrees) {\n    return this.rotateNew(degreesToRadian(degrees));\n  }\n\n  /**\n   * Alias of {@link Vector#rotate__anchor rotate}\n   */\n  rotateBy(radian) {\n\t\treturn this.rotate(radian);\n  }\n  /**\n   * Alias of {@link Vector#rotateNew__anchor rotateNew}\n   */\n  rotateByNew(radian) {\n    return this.rotateNew(radian);\n  }\n\n  /**\n   * Alias of {@link Vector#rotateDeg__anchor rotateDeg}\n   */\n  rotateDegBy(degrees) {\n\t\treturn this.rotateDeg(degrees);\n  }\n  /**\n   * Alias of {@link Vector#rotateDegNew__anchor rotateDegNew}\n   */\n  rotateDegByNew(radian) {\n    return tjos.rotateDegNew(radian);\n  }\n\n  /**\n   * Rotates a vector to a specific angle\n   *\n   * @public\n   * @chainable\n   * @param  {number}  radian The angle, in radians, to rotate the vector to\n   * @return {Vector}\t\t\t\t\tReturns itself, modified\n   */\n\trotateTo(radian) {\n\t\treturn this.rotate(radian-this.angle);\n\t};\n  /**\n   * Clones the vector and rotates it to the supplied radian value\n   *\n   * @public\n   * @chainable\n   * @param  {number}  radian The angle, in radians, to rotate the vector to\n   * @return {Vector}\t\t\t\t\tReturns the clone of itself, modified\n   */\n\trotateToNew(radian) {\n    let v = this.clone();\n    return v.rotateTo(radian);\n\t};\n\n\t/**\n\t * Rotates a vecor to a given amount, provided in degrees. Converts the degree\n\t * value to radians and runs the rotateTo method.\n\t *\n\t * @public\n\t * @chainable\n\t * @param  {number}  degrees The angle, in degrees, to rotate the vector to\n\t * @return {Vector}\t\t\t\t\t\tReturns itself, modified\n\t */\n  rotateToDeg(degrees) {\n    return this.rotateTo(degreesToRadian(degrees));\n  }\n  /**\n   * Clones the vector and rotates it to the supplied degree value\n   *\n   * @public\n   * @chainable\n\t * @param  {number}  degrees The angle, in degrees, to rotate the vector to\n   * @return {Vector}\t\t\t\t\t Returns the clone of itself, modified\n   */\n  rotateToDegNew(degrees) {\n    return this.rotateToNew(degreesToRadian(degrees));\n  }\n\n\t/**\n\t * Normalises the vector down to a length of 1 unit\n\t *\n\t * @public\n\t * @chainable\n\t * @return {Vector}\t\t\t\t\tReturns itself, modified\n\t */\n\tnormalise() {\n\t\treturn this.divideScalar(this.length);\n\t}\n\t/**\n\t * Clones the vector and normalises it\n\t *\n\t * @public\n\t * @chainable\n\t * @return {Vector}\t\t\t\t\tReturns a clone of itself, modified\n\t */\n\tnormaliseNew() {\n\t\treturn this.divideScalarNew(this.length);\n\t}\n\n\t/**\n\t * Calculates the distance between this and the supplied vector\n\t *\n\t * @param  {Vector} vector The vector to calculate the distance from\n\t * @return {number}        The distance between this and the supplied vector\n\t */\n\tdistance(vector) {\n\t\treturn this.subtractNew(vector).length;\n\t}\n\n\t/**\n\t * Calculates the distance on the X axis between this and the supplied vector\n\t *\n\t * @param  {Vector} vector The vector to calculate the distance from\n\t * @return {number}        The distance, along the x axis, between this and the supplied vector\n\t */\n\tdistanceX(vector) {\n\t\treturn this.x - vector.x;\n\t}\n\n\t/**\n\t * Calculated the distance on the Y axis between this and the supplied vector\n\t *\n\t * @param  {Vector} vector The vector to calculate the distance from\n\t * @return {number}        The distance, along the y axis, between this and the supplied vector\n\t */\n\tdistanceY(vector) {\n\t\treturn this.y - vector.y;\n\t}\n\n\n\t/**\n\t * Calculates the dot product between this and a supplied vector\n\t *\n\t * @example\n\t * // returns -14\n\t * new Vector(2, -3).dot(new Vector(-4, 2))\n\t * new Vector(-4, 2).dot(new Vector(2, -3))\n\t * new Vector(2, -4).dot(new Vector(-3, 2))\n\t *\n\t * @param  {Vector} vector The vector object against which to calculate the dot product\n\t * @return {number}        The dot product of the two vectors\n\t */\n\tdot(vector) {\n\t\treturn (this.x * vector.x) + (this.y * vector.y);\n\t}\n\n\t/**\n\t * Calculates the cross product between this and the supplied vector.\n\t *\n\t * @example\n\t * // returns -2\n\t * new Vector(2, -3).cross(new Vector(-4, 2))\n\t * new Vector(-4, 2).cross(new Vector(2, -3))\n\t * // returns 2\n\t * new Vector(2, -4).cross(new Vector(-3, 2))\n\t *\n\t * @param  {Vector} vector The vector object against which to calculate the cross product\n\t * @return {number}        The cross product of the two vectors\n\t */\n\tcross(vector) {\n\t\treturn (this.x * vector.x) - (this.y * vector.y);\n\t}\n\n\n  /**\n   * Getters and setters\n   */\n\n  /**\n   * (getter/setter) The x value of the vector.\n   *\n   * @type {number}\n   * @default 0\n   */\n  set x(x) {\n    if(typeof x == 'number') {\n      this._x = x;\n    } else {\n      throw new TypeError('X should be a number');\n    }\n  }\n  get x() {\n    return this._x || 0;\n  }\n\n /**\n\t* (getter/setter) The y value of the vector.\n\t*\n\t* @type {number}\n\t* @default 0\n\t*/\n  set y(y) {\n    if(typeof y == 'number') {\n      this._y = y;\n    } else {\n      throw new TypeError('Y should be a number');\n    }\n  }\n  get y() {\n    return this._y || 0;\n  }\n\n\t/**\n\t* (getter/setter) The length of the vector presented as a square. If you're using\n\t* length for comparison, this is quicker.\n\t*\n\t* @type {number}\n\t* @default 0\n\t*/\n  set lengthSquared(length) {\n    var factor;\n    if(typeof length == 'number') {\n      factor = length / this.lengthSquared;\n      this.multiplyScalar(factor);\n    } else {\n      throw new TypeError('length should be a number');\n    }\n  }\n  get lengthSquared() {\n    return (this.x * this.x) + (this.y * this.y);\n  }\n\n\t/**\n\t* (getter/setter) The length of the vector\n\t*\n\t* @type {number}\n\t* @default 0\n\t*/\n  set length(length) {\n    var factor;\n    if(typeof length == 'number') {\n      factor = length / this.length;\n      this.multiplyScalar(factor);\n    } else {\n      throw new TypeError('length should be a number');\n    }\n  }\n  get length() {\n    return Math.sqrt(this.lengthSquared);\n  }\n\n\t/**\n\t* (getter/setter) The angle of the vector, in radians\n\t*\n\t* @type {number}\n\t* @default 0\n\t*/\n  set angle(radian) {\n    if(typeof radian == 'number') {\n      this.rotateTo(radian);\n    } else {\n      throw new TypeError('angle should be a number');\n    }\n  }\n  get angle() {\n    return Math.atan2(this.y, this.x);\n  }\n\n\t/**\n\t* (getter/setter) The angle of the vector, in radians\n\t*\n\t* @type {number}\n\t* @default 0\n\t*/\n  set angleInDegrees(degrees) {\n    if(typeof degrees == 'number') {\n      this.rotateToDeg(degrees);\n    } else {\n      throw new TypeError('angle should be a number');\n    }\n  }\n  get angleInDegrees() {\n    return radianToDegrees(Math.atan2(this.y, this.x));\n  }\n\n\t/**\n\t * (getter/setter) Vector width.\n   * Alias of {@link Vector#x x}\n\t *\n\t * @type {number}\n\t */\n\tset width(w) {\n\t\tthis.x = w;\n\t}\n\tget width() {\n\t\treturn this.x;\n\t}\n\n\t/**\n\t * (getter/setter) Vector height.\n   * Alias of {@link Vector#x x}\n\t *\n\t * @type {number}\n\t */\n\tset height(h) {\n\t\tthis.y = h;\n\t}\n\tget height() {\n\t\treturn this.y;\n\t}\n\n\t/**\n\t * (getter/setter) Vector area.\n\t * @readonly\n\t *\n\t * @type {number}\n\t */\n\tget area() {\n\t\treturn this.x * this.y;\n\t}\n\n}\n\n\nclass Actor {\n  constructor(x, y, w, h) {\n    this.dimensions = new Vector(w, h);\n    this.position = new Vector(x, y);\n  }\n  \n  render() {\n    \n  }\n  \n  set dimensions(value) {\n    if(value instanceof Vector) this._dimensions = value;\n  }\n  get dimensions() {\n    return this._dimensions || new Vector(0,0);\n  }\n  \n  set position(value) {\n    if(value instanceof Vector) this._position = value;\n  }\n  get position() {\n    return this._position || new Vector(0,0);\n  }\n}\n\nclass Arrow extends Actor {\n  constructor(x = 200, y = 200, w = 40, h = 20, v) {\n    super(x, y, w, h);\n    \n    this.vector = v;\n    \n    // For the purposes of the Arrow, we actually use the dimensions as the vector\n    \n//     this.onPointerMove = this.onPointerMove.bind(this);\n    \n//     document.addEventListener('application-pointermove', this.onPointerMove, false);\n  }\n  \n  destroy() {\n    // document.removeEventListener('application-pointermove', this.onPointerMove, false);\n    this.destroyed = true;\n  }\n  \n  render(application) {\n    if(this.destroyed) return;\n    if(this.vector.length <= 0.01) return;\n    \n    let context = application.context;\n    let pos = this.position;\n    let end = this.vector.addNew(pos);\n    \n    context.beginPath();\n    context.moveTo(pos.x, pos.y);\n    context.lineWidth = this.strokeWidth;\n    context.strokeStyle = 'RGBA(255,255,255,'+ this.vector.length / 30 +')';\n    context.lineTo(end.x, end.y);\n    context.lineTo(end.x + this.arrowArm1.x, end.y + this.arrowArm1.y);\n    context.moveTo(end.x, end.y);\n    context.lineTo(end.x + this.arrowArm2.x, end.y + this.arrowArm2.y);\n    context.stroke();\n  }\n  \n  preDraw() {}\n  postDraw() {}\n  \n  onPointerMove(e) {\n    let difference = e.detail.pointer.subtractNew(this.position);\n    this.vector.angle = difference.angle;\n  }\n  \n  set vector(value) {\n    // if(value.length > 20) value.length = 20;\n    this.dimensions = value;\n    this.arrowArm1 = this.vector.clone()\n    this.arrowArm1.angle -= 0.785398*3;\n    this.arrowArm1.length = 6;\n    this.arrowArm2 = this.vector.clone()\n    this.arrowArm2.angle += 0.785398*3;\n    this.arrowArm2.length = 6;\n  }\n  get vector() {\n    return this.dimensions;\n  }\n  \n  get strokeStyle() {\n    return 'black';\n  }\n  \n  get strokeWidth() {\n    return 0;\n  }\n}\n\nclass Pill extends Actor {\n  constructor(x = 200, y = 200, w = 40, h = 20) {\n    super(x, y, w, h);\n    \n    this.squareScalar = w > h ? w + 2 : h + 2\n    \n    this.canvas = document.createElement('canvas');\n    this.canvas.width = this.squareScalar;\n    this.canvas.height = this.squareScalar;\n    this.context = this.canvas.getContext('2d');\n    \n    // document.body.appendChild(this.canvas);\n    this.drawShape();\n  }\n  \n  render(application) {\n    let context = application.context;\n    let pos = this.position;\n    let dims = this.dimensions;\n    \n    context.drawImage(this.canvas, pos.x - this.squareScalar / 2, pos.y - this.squareScalar / 2);\n  }\n  \n  preDraw() {}\n  postDraw() {}\n  \n  drawShape() {\n    let dims = this.dimensions;\n    \n    this.context.clearRect(0,0,this.squareScalar,this.squareScalar);\n    \n    this.preDraw();\n    \n    this.context.rect(this.canvas.width / 2 - dims.height / 2, this.canvas.height / 2 - dims.height / 2, dims.width - dims.height, dims.height);\n    this.draw(this.context);\n    this.drawCirc(this.context, this.canvas.width / 2 - dims.height / 2, this.canvas.height / 2, dims.height / 2);\n    this.drawCirc(this.context, this.canvas.width / 2 + dims.height / 2, this.canvas.height / 2, dims.height / 2);\n    \n    this.postDraw();\n  }\n  \n  drawCirc(context, x, y, radius) {\n    context.beginPath();\n    context.arc(x, y, radius, 0, 2 * Math.PI, false);\n    this.draw(context);\n  }\n  \n  draw(context) {\n    this.fill(context);\n    this.stroke(context);\n  }\n  \n  fill(context) {\n    if(this.fillStyle) {\n      context.fillStyle = this.fillStyle;\n      context.fill();\n    }\n  }\n  \n  stroke(context) {\n    if(this.strokeWidth) {\n      context.lineWidth = this.strokeWidth;\n      context.strokeStyle = this.strokeStyle;\n      context.stroke();\n    }\n  }\n  \n  get fillStyle() {\n    return 'black';\n  }\n  \n  get strokeStyle() {\n    return 'green';\n  }\n  \n  get strokeWidth() {\n    return 0;\n  }\n}\n\nclass Creature extends Pill {\n  constructor(x = 200, y = 200, w = 40, h = 20) {\n    super(x, y, w, h);\n    \n    // this.onPointerMove = this.onPointerMove.bind(this);\n    this.onAnimate = this.onAnimate.bind(this);\n    \n    // document.addEventListener('application-pointermove', this.onPointerMove, false);\n    document.addEventListener('application-animate', this.onAnimate, false);\n                              \n    this.friction = 0.99;\n    this.momentum = new Vector(1,0);\n  }\n  \n  onPointerMove(e) {\n    this.targetPos = e.detail.pointer;\n  }\n  \n  onAnimate(e) {\n    if(this.field) {\n      let force = this.field.solveForPosition(this.position).multiplyScalar(0.005);\n      let app = e.detail.application;\n      \n      this.momentum.add(force);\n      this.momentum.multiplyScalar(this.friction);\n      if(this.momentum.length < 1) this.momentum.length = 1;\n      if(this.momentum.length > 10) this.momentum.length = 10;\n      this.position.add(this.momentum);\n      \n      if(this.position.x < -this.dimensions.width*2) {\n        this.position.x = app.dimensions.width + this.dimensions.width;\n      } else if(this.position.x > app.dimensions.width + this.dimensions.width*2) {\n        this.position.x = -this.dimensions.width;\n      }\n      if(this.position.y < -this.dimensions.height*2) {\n        this.position.y = app.dimensions.height + this.dimensions.height;\n      } else if(this.position.y > app.dimensions.height + this.dimensions.height*2) {\n        this.position.y = -this.dimensions.height;\n      }\n      \n      this.angle = this.momentum.angle;\n      this.drawShape();\n    } else if(this.targetPos) {\n      let diff = this.position.subtractNew(this.targetPos);\n      let step = diff.multiplyScalarNew(0.05);\n\n      this.position = this.position.subtractNew(step);\n\n      this.angle = step.angle;\n\n      this.drawShape();\n    }\n  }\n  \n  preDraw() {\n    this.context.translate(this.squareScalar / 2, this.squareScalar / 2);\n    this.context.rotate(this.angle);\n    this.context.translate(-this.squareScalar / 2, -this.squareScalar / 2);\n  }\n  postDraw() {\n    this.context.setTransform(1, 0, 0, 1, 0, 0);\n  }\n  \n  set targetPos(value) {\n    if(value instanceof Vector) {\n      this.oldTargetPos = this._targetPos;\n      this._targetPos = value;\n      // this.difference = this.position.subtractNew(value);\n      // this.angle = this.difference.angle;\n      \n      // this.drawShape();\n    }\n  }\n  get targetPos() {\n    return this._targetPos || new Vector(0,0);\n  }\n  \n  set field(value) {\n    if(value instanceof VectorField) {\n      this._field = value;\n    }\n  }\n  get field() {\n    return this._field || null;\n  }\n}\n\nclass VectorField extends Actor {\n  constructor(x = 0, y = 0, w = 0, h = 0) {\n    super(x, y, w, h);\n    \n    this.noise = new Noise();\n    \n    this.helpers = [];\n    \n    this.mousepos = new Vector(0, 0);\n    \n    this.onResize = this.onResize.bind(this);\n    this.onPointerMove = this.onPointerMove.bind(this);\n    \n    document.addEventListener('application-pointermove', this.onPointerMove, false);\n    window.addEventListener('resize', this.onResize);\n    this.onResize();\n  }\n  \n  render(application) {\n    this.helpers.forEach((helper)=> {\n      helper.render(application);\n    })\n  }\n  \n  preDraw() {}\n  postDraw() {}\n  \n  solveForPosition(v) {\n    if(!v instanceof Vector) return\n    \n    let scale = 500;\n    let envelope = 15;\n    \n    let noise = this.noise.noise(v.x / scale, v.y / scale, this.mousepos.length / scale) * scale;\n    if(noise > envelope) noise = envelope;\n    if(noise < -envelope) noise = -envelope;\n    let noise1 = this.noise.noise(v.y / scale, v.x / scale, this.mousepos.length / scale);\n    let transV = new Vector(1, 0);\n    transV.length = noise;\n    transV.angle = noise1 * 10;\n    return transV;\n        \n    let transv = v.subtractNew(this.mousepos);\n    transv = new Vector(transv.y - transv.x, -transv.x - transv.y);\n    \n    transv.length *= 0.03;\n    if(transv.length > 50) {\n      transv.length = 50;\n    }\n    transv.length -= 50;\n    transv.length *= -1;\n    \n    return transv;\n  }\n  \n  onPointerMove(e) {\n    this.mousepos = e.detail.pointer;\n    \n    this.helpers.forEach((helper)=> {\n      helper.vector = this.solveForPosition(helper.position);\n    });\n  }\n  \n  onResize(e) {\n    this.helpers.forEach((helper)=> {\n      helper.destroy();\n    })\n    this.helpers = [];\n    \n    let w = this.sampleWidth;\n    let curpos = new Vector(0, 0);\n    \n    while(curpos.y < window.innerHeight + w) {\n      curpos.x = 0;\n      while(curpos.x < window.innerWidth + w) {\n        this.helpers.push(new Arrow(curpos.x, curpos.y, 10, 10, this.solveForPosition(curpos)))\n        curpos.x += w;\n      }\n      curpos.y += w;\n    }\n  }\n  \n  set sampleWidth(value) {\n    if(value > 0) this._sampleWidth = value;\n  }\n  get sampleWidth() {\n    return this._sampleWidth || 30;\n  }\n  \n  set mousepos(value) {\n    if(value instanceof Vector) this._mousepos = value;\n  }\n  get mousepos() {\n    return this._mousepos || new Vector(0,0);\n  }\n  \n  get strokeStyle() {\n    return 'black';\n  }\n  \n  get strokeWidth() {\n    return 0;\n  }\n}\n\nclass Application {\n  constructor() {\n    this.stage = document.createElement('canvas');\n    \n    this.animate = this.animate.bind(this);\n    \n    this.onResize = this.onResize.bind(this);\n    this.onPointerDown = this.onPointerDown.bind(this);\n    this.onPointerup = this.onPointerup.bind(this);\n    this.onPointerMove = this.onPointerMove.bind(this);\n    \n    this.initialiseEvents();\n  }\n  \n  initialiseEvents() {\n    window.addEventListener('resize', this.onResize, false);\n    document.addEventListener('pointerdown', this.onPointerDown, false);\n    document.addEventListener('pointerup', this.onPointerup, false);\n    document.addEventListener('pointermove', this.onPointerMove, false);\n  }\n  \n  deInitialiseEvents() {\n    window.removeEventListener('resize', this.onResize, false);\n    document.removeEventListener('pointerdown', this.onPointerDown, false);\n    document.removeEventListener('pointerup', this.onPointerup, false);\n    document.removeEventListener('pointermove', this.onPointerMove, false);\n  }\n  \n  addActor(actor) {\n    if(actor instanceof Actor) {\n      this.actors.push(actor);\n    }\n  }\n  \n  animate() {\n    this.now = Date.now();\n    let interval = this.now - this.then;\n    \n    this.triggerEvent('application-animate', { now: this.now, then: this.then, interval: interval, application: this });\n    \n    this.render();\n    \n    this.then = this.now;\n    \n    if(this.animating) {\n      requestAnimationFrame(this.animate);\n    }\n  }\n  \n  render() {\n    let dims = this.dimensions;\n    \n    this.context.clearRect(0, 0, dims.width, dims.height);\n    // this.context.fillStyle = 'rgba(255,255,255,.5)';\n    // this.context.fillRect(0,0, dims.width, dims.height);\n    \n    this.actors.forEach((actor)=> {\n      actor.render(this);\n    });\n  }\n  \n  onResize(e) {\n    this.dimensions = new Vector(window.innerWidth, window.innerHeight);\n  }\n  onPointerDown(e) {\n    \n  }\n  onPointerup(e) {\n    \n  }\n  onPointerMove(e) {\n    let pointer = new Vector(e.clientX, e.clientY);\n    this.triggerEvent('application-pointermove', { pointer: pointer });\n  }\n  \n  triggerEvent(event, data) {\n    if (window.CustomEvent) {\n      var event = new CustomEvent(event, {detail: data});\n    } else {\n      var event = document.createEvent('CustomEvent');\n      event.initCustomEvent(event, true, true, data);\n    }\n\n    document.dispatchEvent(event);\n  }\n  \n  get actors() {\n    if( !this._actors ) this._actors = [];\n    \n    return this._actors;\n  }\n  \n  set dimensions(value) {\n    if( value instanceof Vector ) {\n      this.stage.width = value.width;\n      this.stage.height = value.height;\n      this._dimensions = value;\n    }\n  }\n  get dimensions() {\n    return this._dimensions || new Vector(0,0)\n  }\n  \n  set stage(value) {\n    if(value instanceof HTMLCanvasElement) {\n      value.className = this.className;\n      this._stage = value;\n      this.context = this.stage.getContext('2d');\n      this.onResize();\n    }\n  }\n  get stage() {\n    return this._stage || null;\n  }\n  \n  set now(value) {\n    if(!isNaN(value)) this._now = value\n  }\n  get now() {\n    return this._now || 0;\n  }\n  \n  set then(value) {\n    if(!isNaN(value)) this._then = value\n  }\n  get then() {\n    return this._then || 0;\n  }\n  \n  set animating(value) {\n    if(value === true && this.animating !== true) {\n      this._animating = true;\n      \n      this.now = Date.now();\n      this.then = this.now;  \n      \n      requestAnimationFrame(this.animate);\n    }\n  }\n  get animating() {\n    return this._animating === true;\n  }\n  \n  get className() {\n    return 'noise';\n  }\n}\n\nclass Noise {\n  constructor(r) {\n    if (r == undefined) r = Math;\n    this.grad3 = [[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0], \n                                   [1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1], \n                                   [0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]]; \n    this.p = [];\n    for (var i=0; i<256; i++) {\n      this.p[i] = Math.floor(r.random()*256);\n    }\n    // To remove the need for index wrapping, double the permutation table length \n    this.perm = []; \n    for(var i=0; i<512; i++) {\n      this.perm[i]=this.p[i & 255];\n    }\n  }\n  \n  dot(g, x, y, z) {\n    return g[0]*x + g[1]*y + g[2]*z; \n  }\n  \n  mix(a, b, t) {\n    return (1.0-t)*a + t*b; \n  }\n  \n  fade(t) {\n    return t*t*t*(t*(t*6.0-15.0)+10.0); \n  }\n  \n  noise(x, y, z) {\n    // Find unit grid cell containing point \n    var X = Math.floor(x); \n    var Y = Math.floor(y); \n    var Z = Math.floor(z); \n\n    // Get relative xyz coordinates of point within that cell \n    x = x - X; \n    y = y - Y; \n    z = z - Z; \n\n    // Wrap the integer cells at 255 (smaller integer period can be introduced here) \n    X = X & 255; \n    Y = Y & 255; \n    Z = Z & 255;\n\n    // Calculate a set of eight hashed gradient indices \n    var gi000 = this.perm[X+this.perm[Y+this.perm[Z]]] % 12; \n    var gi001 = this.perm[X+this.perm[Y+this.perm[Z+1]]] % 12; \n    var gi010 = this.perm[X+this.perm[Y+1+this.perm[Z]]] % 12; \n    var gi011 = this.perm[X+this.perm[Y+1+this.perm[Z+1]]] % 12; \n    var gi100 = this.perm[X+1+this.perm[Y+this.perm[Z]]] % 12; \n    var gi101 = this.perm[X+1+this.perm[Y+this.perm[Z+1]]] % 12; \n    var gi110 = this.perm[X+1+this.perm[Y+1+this.perm[Z]]] % 12; \n    var gi111 = this.perm[X+1+this.perm[Y+1+this.perm[Z+1]]] % 12; \n\n    // The gradients of each corner are now: \n    // g000 = grad3[gi000]; \n    // g001 = grad3[gi001]; \n    // g010 = grad3[gi010]; \n    // g011 = grad3[gi011]; \n    // g100 = grad3[gi100]; \n    // g101 = grad3[gi101]; \n    // g110 = grad3[gi110]; \n    // g111 = grad3[gi111]; \n    // Calculate noise contributions from each of the eight corners \n    var n000= this.dot(this.grad3[gi000], x, y, z); \n    var n100= this.dot(this.grad3[gi100], x-1, y, z); \n    var n010= this.dot(this.grad3[gi010], x, y-1, z); \n    var n110= this.dot(this.grad3[gi110], x-1, y-1, z); \n    var n001= this.dot(this.grad3[gi001], x, y, z-1); \n    var n101= this.dot(this.grad3[gi101], x-1, y, z-1); \n    var n011= this.dot(this.grad3[gi011], x, y-1, z-1); \n    var n111= this.dot(this.grad3[gi111], x-1, y-1, z-1); \n    // Compute the fade curve value for each of x, y, z \n    var u = this.fade(x); \n    var v = this.fade(y); \n    var w = this.fade(z); \n     // Interpolate along x the contributions from each of the corners \n    var nx00 = this.mix(n000, n100, u); \n    var nx01 = this.mix(n001, n101, u); \n    var nx10 = this.mix(n010, n110, u); \n    var nx11 = this.mix(n011, n111, u); \n    // Interpolate the four results along y \n    var nxy0 = this.mix(nx00, nx10, v); \n    var nxy1 = this.mix(nx01, nx11, v); \n    // Interpolate the two last results along z \n    var nxyz = this.mix(nxy0, nxy1, w); \n\n    return nxyz; \n  }\n}\n\n//# sourceURL=webpack://otherside/./src/js/modules/noise.js?")},"./src/js/modules/preloader.js":()=>{eval('const preloader = document.querySelector(".preloader");\n\nwindow.addEventListener("load", () => {\n  preloader.classList.add("hide-preloader");\n});\n\n//# sourceURL=webpack://otherside/./src/js/modules/preloader.js?')}},__webpack_module_cache__={};function __webpack_require__(n){var t=__webpack_module_cache__[n];if(void 0!==t)return t.exports;var e=__webpack_module_cache__[n]={exports:{}};return __webpack_modules__[n](e,e.exports,__webpack_require__),e.exports}__webpack_require__.n=n=>{var t=n&&n.__esModule?()=>n.default:()=>n;return __webpack_require__.d(t,{a:t}),t},__webpack_require__.d=(n,t)=>{for(var e in t)__webpack_require__.o(t,e)&&!__webpack_require__.o(n,e)&&Object.defineProperty(n,e,{enumerable:!0,get:t[e]})},__webpack_require__.o=(n,t)=>Object.prototype.hasOwnProperty.call(n,t),__webpack_require__.r=n=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__("./src/js/index.js")})();